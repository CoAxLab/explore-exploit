function [fittingmethod,p_min,minusloglik_min] = fun_modelfitting(model,actions,muvalue,daysleft,totaldays)
switch model
    case 1
        
        deltaV = fun_deltaV(muvalue,daysleft);
        predictor = [ones(size(actions)),deltaV];
        
        [p_min,~,~] = mnrfit(predictor(:,2:end),2-actions); % exclude the constant term
        minusloglik_min = - sum(log(1./(1+exp(-(predictor*p_min(:)))).*actions+(1-1./(1+exp(-(predictor*p_min(:))))).*(1-actions)));
        
        fittingmethod = 'logitregress';
        
    case {2,3}
        Npar = 3;
        
        % initialize parameters
        sptotalnum = 100;
        sppars0 = rand(Npar,sptotalnum);
        switch model
            case 2
                sppars0(1,:) = 0.2*sppars0(1,:); % k
                sppars0(2,:) = sppars0(2,:) + 2.5; % b
            case 3
                sppars0(1,:) = sppars0(1,:); % k
                sppars0(2,:) = sppars0(2,:) + 2.5; % b
        end
        sppars0(end,:) = sppars0(end,:) + 1; % log(beta)
        
        pars = nan(Npar,sptotalnum); minusllh = nan(1,sptotalnum); exitflag = nan(1,sptotalnum);
        
        numnotmature = 0;
        
        for spnum = 1:sptotalnum
            spnum
            pars0 = sppars0(:,spnum);
            
            % options for fmincon
            options.display = 'iter';
            options.MaxFunEvals = 10000;
            options.MaxIterations = 1000;
            options.Algorithm = 'quasi-newton';
            
            fun = @(pars)optimizefun_thresholdF(model,pars,actions,muvalue,daysleft,totaldays);
            [pars(:,spnum),minusllh(spnum),exitflag(spnum)] = fminunc(fun,pars0,options);
            
            % change it back to original scale
            pars(end,spnum) = exp(pars(end,spnum));
            
            if exitflag(spnum) == 0
                numnotmature = numnotmature+1;
            end
        end
        
        [minvalue,minind] = min(minusllh);
        p_min = pars(:,minind)';
        minusloglik_min = minvalue;
        
        fittingmethod = ['fminunc_logscale_spnum' num2str(sptotalnum)];
        
    case {4,5}
        Npar = 4;
        
        % initialize parameters
        sptotalnum = 100;
        sppars0 = rand(Npar,sptotalnum);
        switch model
            case 4
                sppars0(1,:) = 0.2*sppars0(1,:); % k
                sppars0(2,:) = sppars0(2,:) + 2.5; % b
            case 5
                sppars0(1,:) = sppars0(1,:); % k
                sppars0(2,:) = sppars0(2,:) + 2.5; % b
        end
        sppars0(end-1,:) = - sppars0(end-1,:) - 1; % log(sigma)
        sppars0(end,:) = sppars0(end,:) + 1; % log(beta)
        
        pars = nan(Npar,sptotalnum); minusllh = nan(1,sptotalnum); exitflag = nan(1,sptotalnum);
        
        numnotmature = 0;
        
        for spnum = 1:sptotalnum
            spnum
            pars0 = sppars0(:,spnum);
            
            % options for fmincon
            options.display = 'iter';
            options.MaxFunEvals = 10000;
            options.MaxIterations = 1000;
            options.Algorithm = 'quasi-newton';
            
            fun = @(pars)optimizefun_thresholdV(model,pars,actions,muvalue,daysleft,totaldays);
            [pars(:,spnum),minusllh(spnum),exitflag(spnum)] = fminunc(fun,pars0,options);
            
            % change it back to original scale
            pars(end-1:end,spnum) = exp(pars(end-1:end,spnum));
            
            if exitflag(spnum) == 0
                numnotmature = numnotmature+1;
            end
        end
        
        [minvalue,minind] = min(minusllh);
        p_min = pars(:,minind)';
        minusloglik_min = minvalue;
        
        fittingmethod = ['fminunc_logscale_spnum' num2str(sptotalnum)];
end
end
